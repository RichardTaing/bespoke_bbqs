{"ast":null,"code":"import { base_url } from \"../../constants\";\nexport const GET_PRODUCTS = \"GET_PRODUCTS\";\nexport const GET_PRODUCT_CATEGORIES = \"GET_PRODUCT_CATEGORIES\";\nexport const getProducts = (categorySlug = \"\", filter) => {\n  return async dispatch => {\n    try {\n      categorySlug = categorySlug === \"all\" ? \"\" : categorySlug;\n      let query = \"\";\n\n      if (filter) {\n        query = \"?filter=1&\";\n\n        for (let prop in filter) {\n          query += \"\".concat(prop, \"=\").concat(filter[prop], \"&\");\n        }\n\n        query = query.substring(0, query.length - 1);\n      }\n\n      const response = await fetch(\"\".concat(base_url, \"/products/\").concat(categorySlug).concat(query));\n      const jsonResponse = await response.json();\n\n      if (response.status === 200) {\n        dispatch({\n          type: GET_PRODUCTS,\n          products: jsonResponse.message\n        });\n      }\n\n      return jsonResponse;\n    } catch (error) {\n      console.log(error);\n    }\n  };\n};\nexport const getCategories = () => {\n  return dispatch => {\n    fetch(\"\".concat(base_url, \"/category\"), {\n      headers: {\n        \"Content-Type\": \"application/json\"\n      }\n    }).then(response => response.json()).then(jsonResponse => {\n      dispatch({\n        type: GET_PRODUCT_CATEGORIES,\n        categories: jsonResponse.message\n      });\n    }).catch(error => {\n      console.log(error);\n    });\n  };\n};\nexport const getSingleProduct = productSlug => {\n  return async dispatch => {\n    try {\n      const response = await fetch(\"\".concat(base_url, \"/products/category/\").concat(productSlug));\n      const jsonResponse = await response.json();\n\n      if (response.status === 200) {}\n    } catch (error) {\n      console.log(error);\n    }\n  };\n};","map":{"version":3,"sources":["/Users/rst_979/MonashBootCamp/bespoke_bbqs/src/store/actions/productActions.js"],"names":["base_url","GET_PRODUCTS","GET_PRODUCT_CATEGORIES","getProducts","categorySlug","filter","dispatch","query","prop","substring","length","response","fetch","jsonResponse","json","status","type","products","message","error","console","log","getCategories","headers","then","categories","catch","getSingleProduct","productSlug"],"mappings":"AAAA,SAASA,QAAT,QAAyB,iBAAzB;AAEA,OAAO,MAAMC,YAAY,GAAG,cAArB;AACP,OAAO,MAAMC,sBAAsB,GAAG,wBAA/B;AAEP,OAAO,MAAMC,WAAW,GAAG,CAACC,YAAY,GAAG,EAAhB,EAAoBC,MAApB,KAA+B;AACxD,SAAO,MAAMC,QAAN,IAAkB;AACvB,QAAI;AACFF,MAAAA,YAAY,GAAGA,YAAY,KAAK,KAAjB,GAAyB,EAAzB,GAA8BA,YAA7C;AAEA,UAAIG,KAAK,GAAG,EAAZ;;AACA,UAAIF,MAAJ,EAAY;AACVE,QAAAA,KAAK,GAAG,YAAR;;AACA,aAAK,IAAIC,IAAT,IAAiBH,MAAjB,EAAyB;AACvBE,UAAAA,KAAK,cAAOC,IAAP,cAAeH,MAAM,CAACG,IAAD,CAArB,MAAL;AACD;;AACDD,QAAAA,KAAK,GAAGA,KAAK,CAACE,SAAN,CAAgB,CAAhB,EAAmBF,KAAK,CAACG,MAAN,GAAe,CAAlC,CAAR;AACD;;AAED,YAAMC,QAAQ,GAAG,MAAMC,KAAK,WACvBZ,QADuB,uBACFI,YADE,SACaG,KADb,EAA5B;AAGA,YAAMM,YAAY,GAAG,MAAMF,QAAQ,CAACG,IAAT,EAA3B;;AACA,UAAIH,QAAQ,CAACI,MAAT,KAAoB,GAAxB,EAA6B;AAC3BT,QAAAA,QAAQ,CAAC;AACPU,UAAAA,IAAI,EAAEf,YADC;AAEPgB,UAAAA,QAAQ,EAAEJ,YAAY,CAACK;AAFhB,SAAD,CAAR;AAID;;AAED,aAAOL,YAAP;AACD,KAxBD,CAwBE,OAAOM,KAAP,EAAc;AACdC,MAAAA,OAAO,CAACC,GAAR,CAAYF,KAAZ;AACD;AACF,GA5BD;AA6BD,CA9BM;AAgCP,OAAO,MAAMG,aAAa,GAAG,MAAM;AACjC,SAAOhB,QAAQ,IAAI;AACjBM,IAAAA,KAAK,WAAIZ,QAAJ,gBAAyB;AAC5BuB,MAAAA,OAAO,EAAE;AACP,wBAAgB;AADT;AADmB,KAAzB,CAAL,CAKGC,IALH,CAKQb,QAAQ,IAAIA,QAAQ,CAACG,IAAT,EALpB,EAMGU,IANH,CAMQX,YAAY,IAAI;AACpBP,MAAAA,QAAQ,CAAC;AACPU,QAAAA,IAAI,EAAEd,sBADC;AAEPuB,QAAAA,UAAU,EAAEZ,YAAY,CAACK;AAFlB,OAAD,CAAR;AAID,KAXH,EAYGQ,KAZH,CAYSP,KAAK,IAAI;AACdC,MAAAA,OAAO,CAACC,GAAR,CAAYF,KAAZ;AACD,KAdH;AAeD,GAhBD;AAiBD,CAlBM;AAoBP,OAAO,MAAMQ,gBAAgB,GAAGC,WAAW,IAAI;AAC7C,SAAO,MAAMtB,QAAN,IAAkB;AACvB,QAAI;AACF,YAAMK,QAAQ,GAAG,MAAMC,KAAK,WACvBZ,QADuB,gCACO4B,WADP,EAA5B;AAGA,YAAMf,YAAY,GAAG,MAAMF,QAAQ,CAACG,IAAT,EAA3B;;AACA,UAAIH,QAAQ,CAACI,MAAT,KAAoB,GAAxB,EAA6B,CAC5B;AACF,KAPD,CAOE,OAAOI,KAAP,EAAc;AACdC,MAAAA,OAAO,CAACC,GAAR,CAAYF,KAAZ;AACD;AACF,GAXD;AAYD,CAbM","sourcesContent":["import { base_url } from \"../../constants\";\n\nexport const GET_PRODUCTS = \"GET_PRODUCTS\";\nexport const GET_PRODUCT_CATEGORIES = \"GET_PRODUCT_CATEGORIES\";\n\nexport const getProducts = (categorySlug = \"\", filter) => {\n  return async dispatch => {\n    try {\n      categorySlug = categorySlug === \"all\" ? \"\" : categorySlug;\n\n      let query = \"\";\n      if (filter) {\n        query = \"?filter=1&\";\n        for (let prop in filter) {\n          query += `${prop}=${filter[prop]}&`;\n        }\n        query = query.substring(0, query.length - 1);\n      }\n\n      const response = await fetch(\n        `${base_url}/products/${categorySlug}${query}`\n      );\n      const jsonResponse = await response.json();\n      if (response.status === 200) {\n        dispatch({\n          type: GET_PRODUCTS,\n          products: jsonResponse.message\n        });\n      }\n\n      return jsonResponse;\n    } catch (error) {\n      console.log(error);\n    }\n  };\n};\n\nexport const getCategories = () => {\n  return dispatch => {\n    fetch(`${base_url}/category`, {\n      headers: {\n        \"Content-Type\": \"application/json\"\n      }\n    })\n      .then(response => response.json())\n      .then(jsonResponse => {\n        dispatch({\n          type: GET_PRODUCT_CATEGORIES,\n          categories: jsonResponse.message\n        });\n      })\n      .catch(error => {\n        console.log(error);\n      });\n  };\n};\n\nexport const getSingleProduct = productSlug => {\n  return async dispatch => {\n    try {\n      const response = await fetch(\n        `${base_url}/products/category/${productSlug}`\n      );\n      const jsonResponse = await response.json();\n      if (response.status === 200) {\n      }\n    } catch (error) {\n      console.log(error);\n    }\n  };\n};\n"]},"metadata":{},"sourceType":"module"}